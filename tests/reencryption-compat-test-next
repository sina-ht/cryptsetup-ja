#!/bin/bash

CRYPTSETUP=../cryptsetup
REENC="$CRYPTSETUP reencrypt"
FAST_PBKDF_ARGON="--pbkdf-force-iterations 4 --pbkdf-memory 32 --pbkdf-parallel 1"
FAST_PBKDF_PBKDF2="--pbkdf-force-iterations 1000 --pbkdf pbkdf2"
DEFAULT_ARGON="argon2i"

DEV=""
DEV_SHRINK="dm-reenc-shrink"
DEV_NAME=reenc9768
IMG=reenc-data
IMG_HDR=/tmp/$IMG.hdr
KEY1=key1
PWD1="93R4P4pIqAH8"
PWD2="1cND4319812f"
PWD3="1-9Qu5Ejfnqv"

function dm_crypt_features()
{
	VER_STR=$(dmsetup targets | grep crypt | cut -f2 -dv)
	[ -z "$VER_STR" ] && fail "Failed to parse dm-crypt version."

	VER_MAJ=$(echo $VER_STR | cut -f 1 -d.)
	VER_MIN=$(echo $VER_STR | cut -f 2 -d.)
	VER_PTC=$(echo $VER_STR | cut -f 3 -d.)

	[ $VER_MAJ -lt 1 ] && return
	[ $VER_MAJ -gt 1 ] && {
		DM_PERF_CPU=1
		DM_SECTOR_SIZE=1
		return
	}

	[ $VER_MIN -lt 14 ] && return
	DM_PERF_CPU=1
	if [ $VER_MIN -ge 17 -o \( $VER_MIN -eq 14 -a $VER_PTC -ge 5 \) ]; then
		DM_SECTOR_SIZE=1
	fi
}

# $1 path to scsi debug bdev
scsi_debug_teardown() {
	local _tries=15;

	while [ -b "$1" -a $_tries -gt 0 ]; do
		rmmod scsi_debug 2> /dev/null
		if [ -b "$1" ]; then
			sleep .1
			_tries=$((_tries-1))
		fi
	done

	test ! -b "$1" || rmmod scsi_debug
}

function remove_mapping()
{
	[ -b /dev/mapper/$DEV_SHRINK ] && dmsetup remove $DEV_SHRINK
	[ -b /dev/mapper/$DEV_NAME2 ] && dmsetup remove $DEV_NAME2
	[ -b /dev/mapper/$DEV_NAME ] && dmsetup remove $DEV_NAME
	rm -f $IMG $IMG_HDR $KEY1 >/dev/null 2>&1
	rmmod scsi_debug 2> /dev/null
	scsi_debug_teardown $DEV
}

function fail()
{
	[ -n "$1" ] && echo "$1"
	echo "FAILED at line $(caller)"
	remove_mapping
	exit 2
}

function skip()
{
	[ -n "$1" ] && echo "$1"
	exit 77
}

function add_scsi_device() {
	scsi_debug_teardown $DEV
        modprobe scsi_debug $@ delay=0
        if [ $? -ne 0 ] ; then
                echo "This kernel seems to not support proper scsi_debug module, test skipped."
                exit 77
        fi

        sleep 1
        DEV="/dev/"$(grep -l -e scsi_debug /sys/block/*/device/model | cut -f4 -d /)
        [ -b $DEV ] || fail "Cannot find $DEV."
}

function open_crypt() # $1 pwd, $2 hdr
{
	if [ -n "$2" ] ; then
		echo "$1" | $CRYPTSETUP luksOpen $DEV $DEV_NAME --header $2 || fail
	elif [ -n "$1" ] ; then
		echo "$1" | $CRYPTSETUP luksOpen $DEV $DEV_NAME || fail
	else
		$CRYPTSETUP luksOpen -d $KEY1 $DEV $DEV_NAME || fail
	fi
}

function wipe_dev() # $1 dev
{
	blkdiscard --zeroout $1 2>/dev/null || dd if=/dev/zero of=$1 bs=1M conv=notrunc >/dev/null 2>&1
}

function wipe() # $1 pass, $2 hdr
{
	open_crypt $1 $2
	wipe_dev /dev/mapper/$DEV_NAME
	udevadm settle >/dev/null 2>&1
	$CRYPTSETUP luksClose $DEV_NAME || fail
}

function prepare() # $1 dev1_siz
{
	remove_mapping

	if [ ! -e $KEY1 ]; then
		dd if=/dev/urandom of=$KEY1 count=1 bs=32 >/dev/null 2>&1
	fi

	add_scsi_device $@
}

function check_hash_dev() # $1 dev, $2 hash
{
	HASH=$(sha256sum $1 | cut -d' ' -f 1)
	[ $HASH != "$2" ] && fail "HASH differs (expected: $2) (result $HASH)"
}

function check_hash() # $1 pwd, $2 hash, $3 hdr
{
	open_crypt $1 $3
	check_hash_dev /dev/mapper/$DEV_NAME $2
	$CRYPTSETUP remove $DEV_NAME || fail
}

function check_hash_head() # $1 pwd, $2 len, $3 hash, $4 hdr
{
	open_crypt $1 $4
	test -z "$3" || echo $1 | $CRYPTSETUP resize $DEV_NAME --size $2 || fail
	check_hash_dev /dev/mapper/$DEV_NAME $3
	$CRYPTSETUP remove $DEV_NAME || fail
}

function shrink_dev() # $1 dev, $2 shrink sectors
{
	local _bdev_size=$(blockdev --getsz $1)
	_bdev_size=$((_bdev_size-$2))

	dmsetup create $DEV_SHRINK --table "0 $_bdev_size linear $1 0" || fail
}

[ $(id -u) != 0 ] && skip "WARNING: You must be root to run this test, test skipped."
[ ! -x "$CRYPTSETUP" ] && skip "Cannot find $CRYPTSETUP, test skipped."
modprobe --dry-run scsi_debug || exit 77
dm_crypt_features

# REENCRYPTION tests

# 252 MiBs of zeros (256MiBs - 4MiB LUKS2 header)
HASH1=c2726f08d0177d1f658c4481190c914030028d6c9ff73bd6f28297051d60e53c
# 1 MiB of zeros
HASH2=30e14955ebf1352266dc2ff8067e68104607e750abb9d3b36582b8af909fcb58
# 256 MiBs of zeros
HASH3=a6d72ac7690f53be6ae46ba88506bd97302a093f7108472bd9efc3cefda06484
# 64 MiBs of zeroes
HASH4=3b6a07d0d404fab4e23b6d34bc6696a6a312dd92821332385e5af7c01c421351
# 56 MiBs of zeroes
HASH5=8afcb7e7189ce4d112fd245eaa60c3cfcf5a5d5e1d6bf4eb85941d73ef8cfbd5
# 43 MiBs of zeroes
HASH6=39f7c6d38af574fe2c90ef400dfaba8ef8edccd11bdac998a3f8143a86837331
# 31 MiBs of zeroes
HASH7=18a393d1a505e22ccf3e29effe3005ea8627e4c36b7cca0e53f58121f49b67e1

echo "[1] Reencryption"
echo -n "[512 sector]"
prepare dev_size_mb=256
echo $PWD1 | $CRYPTSETUP -q luksFormat --type luks2 -s 128 -c aes-cbc-plain --offset 8192 $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo -n "[OK][4096 sector]"
prepare sector_size=4096 dev_size_mb=256
echo $PWD1 | $CRYPTSETUP -q luksFormat --type luks2 -s 128 -c aes-cbc-plain --offset 8192 $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
if [ -n "$DM_SECTOR_SIZE" ]; then
	echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON --sector-size 4096 || fail
	check_hash $PWD1 $HASH1
	echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal --sector-size 2048 $FAST_PBKDF_ARGON || fail
	check_hash $PWD1 $HASH1
	echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON --sector-size 1024 || fail
	check_hash $PWD1 $HASH1
	echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum --sector-size 512 $FAST_PBKDF_ARGON || fail
	check_hash $PWD1 $HASH1
fi
echo -n "[OK][4096/512 sector]"
prepare sector_size=512 physblk_exp=3 dev_size_mb=256
echo $PWD1 | $CRYPTSETUP -q luksFormat --type luks2 -s 128 -c aes-cbc-plain --offset 8192 $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH1
echo "[OK]"

# reencrypt minimal device size (FIXME: change data device size to single encryption sector size)
# temporary small device size is default luks2 hdr size + 1MiB
echo -n "[small device reencryption]"
prepare dev_size_mb=5
echo $PWD1 | $CRYPTSETUP -q luksFormat --type luks2 -s 128 -c aes-cbc-plain --offset 8192 $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1
check_hash $PWD1 $HASH2
echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH2
echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH2
echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH2
echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum $FAST_PBKDF_ARGON || fail
check_hash $PWD1 $HASH2
if [ -n "$DM_SECTOR_SIZE" ]; then
	echo $PWD1 | $REENC $DEV -q $FAST_PBKDF_ARGON --sector-size 4096 || fail
	check_hash $PWD1 $HASH2
	echo $PWD1 | $REENC $DEV -q -s 256 -c twofish-cbc-plain --resilience journal --sector-size 2048 $FAST_PBKDF_ARGON || fail
	check_hash $PWD1 $HASH2
	echo $PWD1 | $REENC $DEV -q --resilience noop $FAST_PBKDF_ARGON --sector-size 1024 || fail
	check_hash $PWD1 $HASH2
	echo $PWD1 | $REENC $DEV -q -s 128 -c aes-cbc-plain --resilience checksum --sector-size 512 $FAST_PBKDF_ARGON || fail
	check_hash $PWD1 $HASH2
fi
echo "[OK]"

#TODO:
# echo "[2] Reencryption with data shift"

echo "[2] Encryption with data shift"
# well, movin' zeroes :-)
prepare dev_size_mb=64
wipe_dev $DEV
check_hash_dev $DEV $HASH4
echo $PWD1 | $REENC $DEV --encrypt -c aes-cbc-essiv:sha256 -s 128 --reduce-device-size 8M -q $FAST_PBKDF_ARGON || fail
check_hash_head $PWD1 $((56*1024*2)) $HASH5
wipe_dev $DEV
check_hash_dev $DEV $HASH4
echo $PWD1 | $REENC $DEV --encrypt -c twofish-cbc-plain -s 128 --reduce-device-size 21M -q $FAST_PBKDF_ARGON || fail
check_hash_head $PWD1 $((43*1024*2)) $HASH6
wipe_dev $DEV
echo $PWD1 | $REENC $DEV --encrypt --reduce-device-size 33M -q $FAST_PBKDF_ARGON || fail
check_hash_head $PWD1 $((31*1024*2)) $HASH7
wipe_dev $DEV
echo $PWD1 | $REENC $DEV --encrypt --reduce-device-size 64M -q $FAST_PBKDF_ARGON > /dev/null 2>&1 && fail
echo $PWD1 | $REENC --encrypt --reduce-device-size 8M --init-only -q $FAST_PBKDF_ARGON $DEV || fail
shrink_dev $DEV 1
echo $PWD1 | $REENC /dev/mapper/$DEV_SHRINK 2> /dev/null && fail
dmsetup remove $DEV_SHRINK

echo "[3] Encryption with detached header"
prepare dev_size_mb=256
wipe_dev $DEV
echo $PWD1 | $REENC --encrypt -c aes-cbc-essiv:sha256 -s 128 --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
wipe_dev $DEV
echo $PWD1 | $REENC --encrypt --resilience journal --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
wipe_dev $DEV
echo $PWD1 | $REENC --encrypt -c twofish-cbc-plain -s 128 --resilience noop --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
wipe_dev $DEV
echo $PWD1 | $REENC --encrypt -c serpent-xts-plain --resilience checksum --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR

echo "[4] Reencryption with detached header"
wipe $PWD1 $IMG_HDR
echo $PWD1 | $REENC -c aes-cbc-essiv:sha256 -s 128 --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
echo $PWD1 | $REENC --resilience journal --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
echo $PWD1 | $REENC -c twofish-cbc-plain -s 128 --resilience noop --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR
echo $PWD1 | $REENC -c serpent-xts-plain --resilience checksum --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
check_hash $PWD1 $HASH3 $IMG_HDR

echo "[5] Decryption with detached header"
echo $PWD1 | $CRYPTSETUP luksFormat --type luks2 -c aes-cbc-essiv:sha256 -s 128 --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1 $IMG_HDR
echo $PWD1 | $REENC -q --decrypt --header $IMG_HDR $DEV || fail
check_hash_dev $DEV $HASH3
echo $PWD1 | $CRYPTSETUP luksFormat --type luks2 --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1 $IMG_HDR
echo $PWD1 | $REENC -q --decrypt --resilience journal --header $IMG_HDR $DEV || fail
check_hash_dev $DEV $HASH3
echo $PWD1 | $CRYPTSETUP luksFormat --type luks2 -c twofish-cbc-plain -s 128 --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1 $IMG_HDR
echo $PWD1 | $REENC -q --decrypt --resilience noop --header $IMG_HDR $DEV || fail
check_hash_dev $DEV $HASH3
echo $PWD1 | $CRYPTSETUP luksFormat --type luks2 -c serpent-xts-plain --header $IMG_HDR -q $FAST_PBKDF_ARGON $DEV || fail
wipe $PWD1 $IMG_HDR
echo $PWD1 | $REENC -q --decrypt --resilience checksum --header $IMG_HDR $DEV || fail
check_hash_dev $DEV $HASH3

remove_mapping
exit 0
